# แล็บปฏิบัติการ: โครงสร้างพื้นฐานกุญแจสาธารณะ (PKI) - คู่มือทบทวนแบบทำตามได้

## คำแนะนำ
เอกสารนี้ออกแบบมาเพื่อให้นักศึกษาสามารถทบทวนและฝึกปฏิบัติเกี่ยวกับ PKI ด้วยตนเอง โดยมีคำอธิบายและคำตอบในแต่ละขั้นตอน นักศึกษาสามารถทำตามได้ง่ายและเห็นผลลัพธ์ที่ถูกต้อง

---

## วัตถุประสงค์
- ทบทวนความรู้และทักษะการใช้งานโครงสร้างพื้นฐานกุญแจสาธารณะ (PKI)
- ฝึกปฏิบัติการสร้างและใช้งานคู่กุญแจ การลงนามดิจิทัล และใบรับรองดิจิทัล
- เข้าใจการทำงานของระบบ PKI ในโลกจริงผ่านการจำลองการใช้งาน HTTPS

## เครื่องมือที่จำเป็น
- OpenSSL (ติดตั้งไว้แล้วใน Linux และ macOS, สำหรับ Windows ให้ติดตั้งผ่าน Git Bash หรือใช้ WSL)
- เว็บเบราว์เซอร์
- Terminal หรือ Command Prompt

## ส่วนที่ 1: การสร้างและใช้งานคู่กุญแจ RSA

### ขั้นตอนที่ 1.1: สร้างกุญแจส่วนตัว RSA

```bash
# สร้างกุญแจส่วนตัว RSA ขนาด 2048 บิต
openssl genrsa -out private_key.pem 2048
```

คำอธิบาย:
- `genrsa` คือคำสั่งสำหรับสร้างกุญแจ RSA
- `-out private_key.pem` ระบุชื่อไฟล์ที่จะเก็บกุญแจส่วนตัว
- `2048` คือขนาดของกุญแจเป็นบิต (ยิ่งมากยิ่งปลอดภัย แต่ประมวลผลช้าลง)

ผลลัพธ์ที่ควรได้:
```
Generating RSA private key, 2048 bit long modulus
..................+++
.........................+++
e is 65537 (0x10001)
```

### ขั้นตอนที่ 1.2: สกัดกุญแจสาธารณะจากกุญแจส่วนตัว

```bash
# สกัดกุญแจสาธารณะจากกุญแจส่วนตัว
openssl rsa -in private_key.pem -pubout -out public_key.pem
```

คำอธิบาย:
- `-in private_key.pem` ระบุไฟล์กุญแจส่วนตัวที่จะใช้
- `-pubout` ระบุว่าต้องการสกัดกุญแจสาธารณะ
- `-out public_key.pem` ระบุชื่อไฟล์ที่จะเก็บกุญแจสาธารณะ

ผลลัพธ์ที่ควรได้:
```
writing RSA key
```

### ขั้นตอนที่ 1.3: ดูเนื้อหาของกุญแจส่วนตัวและกุญแจสาธารณะ

```bash
# ดูเนื้อหาของกุญแจส่วนตัว
openssl rsa -in private_key.pem -text -noout

# ดูเนื้อหาของกุญแจสาธารณะ
openssl rsa -in public_key.pem -pubin -text -noout
```

คำอธิบาย:
- `-text` แสดงข้อมูลในรูปแบบที่อ่านได้
- `-noout` ไม่แสดงเนื้อหาของกุญแจในรูปแบบ PEM
- `-pubin` ระบุว่าไฟล์อินพุตเป็นกุญแจสาธารณะ

ผลลัพธ์ที่ควรได้:
กุญแจส่วนตัวจะแสดงค่า modulus (n), publicExponent (e), privateExponent (d) และค่าอื่นๆ
กุญแจสาธารณะจะแสดงเฉพาะ modulus (n) และ publicExponent (e)

### ขั้นตอนที่ 1.4: เข้ารหัสและถอดรหัสข้อความ

1. สร้างไฟล์ข้อความ:
```bash
# สร้างไฟล์ข้อความสั้นที่มีข้อความเป็นภาษาไทย
echo "สวัสดี นี่คือข้อความทดสอบ PKI" > message.txt
```

2. เข้ารหัสข้อความด้วยกุญแจสาธารณะ:
```bash
# เข้ารหัสข้อความด้วยกุญแจสาธารณะ
openssl rsautl -encrypt -pubin -inkey public_key.pem -in message.txt -out encrypted.bin
```

3. ถอดรหัสข้อความด้วยกุญแจส่วนตัว:
```bash
# ถอดรหัสข้อความด้วยกุญแจส่วนตัว
openssl rsautl -decrypt -inkey private_key.pem -in encrypted.bin -out decrypted.txt
```

4. ตรวจสอบผลลัพธ์:
```bash
# แสดงข้อความที่ถอดรหัสแล้ว
cat decrypted.txt
```

คำอธิบาย:
- `rsautl` ใช้สำหรับการเข้า/ถอดรหัสข้อความโดยตรง
- `-encrypt` ใช้สำหรับการเข้ารหัส
- `-decrypt` ใช้สำหรับการถอดรหัส
- `-pubin` ระบุว่าเป็นการใช้กุญแจสาธารณะ
- `-inkey` ระบุไฟล์กุญแจที่จะใช้
- `-in` และ `-out` ระบุไฟล์อินพุตและเอาต์พุต

**หมายเหตุสำคัญ**: RSA โดยตรงสามารถเข้ารหัสข้อความที่มีขนาดไม่เกินขนาดของกุญแจ (เช่น สำหรับกุญแจ 2048 บิต สามารถเข้ารหัสได้ไม่เกิน 245 ไบต์) ดังนั้นวิธีนี้เหมาะสำหรับข้อความสั้นๆ เท่านั้น

## ส่วนที่ 2: การสร้างและตรวจสอบลายมือชื่อดิจิทัล

### ขั้นตอนที่ 2.1: สร้างเอกสารสำหรับลงนาม

```bash
# สร้างไฟล์เอกสาร
cat > document.txt << EOF
เอกสารเกี่ยวกับประโยชน์ของ PKI

โครงสร้างพื้นฐานกุญแจสาธารณะ (PKI) มีประโยชน์ดังนี้:
1. รับรองความถูกต้องของตัวตน (Authentication)
2. รักษาความลับของข้อมูล (Confidentiality)
3. รับรองความถูกต้องของข้อมูล (Integrity)
4. ไม่สามารถปฏิเสธความรับผิดชอบได้ (Non-repudiation)

PKI ถูกใช้ในหลายระบบ เช่น:
- การเชื่อมต่อเว็บไซต์แบบ HTTPS
- ระบบอีเมลที่มีการเข้ารหัส
- ระบบลายมือชื่ออิเล็กทรอนิกส์
- บัตรสมาร์ทการ์ด
EOF
```

### ขั้นตอนที่ 2.2: สร้างลายมือชื่อดิจิทัล

```bash
# สร้างลายมือชื่อดิจิทัลด้วยอัลกอริทึม SHA-256
openssl dgst -sha256 -sign private_key.pem -out signature.bin document.txt
```

คำอธิบาย:
- `dgst` ใช้สำหรับการคำนวณและจัดการค่าแฮช
- `-sha256` เลือกใช้อัลกอริทึมแฮช SHA-256
- `-sign private_key.pem` ระบุกุญแจส่วนตัวที่จะใช้ในการลงนาม
- `-out signature.bin` ระบุไฟล์ที่จะเก็บลายมือชื่อ
- `document.txt` ไฟล์ที่จะลงนาม

### ขั้นตอนที่ 2.3: ตรวจสอบลายมือชื่อดิจิทัล

```bash
# ตรวจสอบลายมือชื่อดิจิทัล
openssl dgst -sha256 -verify public_key.pem -signature signature.bin document.txt
```

ผลลัพธ์ที่ควรได้:
```
Verified OK
```

### ขั้นตอนที่ 2.4: ทดสอบการแก้ไขเอกสาร

```bash
# สร้างสำเนาของเอกสารและแก้ไขเล็กน้อย
cp document.txt document_modified.txt
echo "เพิ่มข้อความนี้เข้าไป" >> document_modified.txt

# ตรวจสอบลายมือชื่อกับเอกสารที่แก้ไขแล้ว
openssl dgst -sha256 -verify public_key.pem -signature signature.bin document_modified.txt
```

ผลลัพธ์ที่ควรได้:
```
Verification Failure
```

คำอธิบาย:
- การแก้ไขเอกสารแม้เพียงเล็กน้อยจะทำให้ค่าแฮชเปลี่ยนไป
- ลายมือชื่อดิจิทัลจะตรวจสอบความถูกต้องของเอกสารโดยใช้ค่าแฮช
- เมื่อเอกสารถูกแก้ไข ค่าแฮชจะเปลี่ยนไป ทำให้การตรวจสอบลายมือชื่อล้มเหลว

### ขั้นตอนที่ 2.5: ตรวจสอบค่าแฮชของเอกสาร

```bash
# แสดงค่าแฮช SHA-256 ของเอกสารต้นฉบับ
openssl dgst -sha256 document.txt

# แสดงค่าแฮช SHA-256 ของเอกสารที่แก้ไขแล้ว
openssl dgst -sha256 document_modified.txt
```

คำอธิบาย:
- จะเห็นได้ว่าค่าแฮชของทั้งสองไฟล์แตกต่างกัน แม้ว่าการแก้ไขจะเป็นเพียงการเพิ่มข้อความสั้นๆ
- ลายมือชื่อดิจิทัลประกอบด้วยค่าแฮชของเอกสารที่ถูกเข้ารหัสด้วยกุญแจส่วนตัว
- เมื่อตรวจสอบลายมือชื่อ ระบบจะถอดรหัสค่าแฮชที่บันทึกไว้ในลายมือชื่อ (โดยใช้กุญแจสาธารณะ) แล้วเปรียบเทียบกับค่าแฮชที่คำนวณได้จากเอกสารปัจจุบัน

## ส่วนที่ 3: การสร้างและทดสอบใบรับรองดิจิทัล

### ขั้นตอนที่ 3.1: สร้าง Certificate Authority (CA)

1. สร้างกุญแจส่วนตัวสำหรับ CA:
```bash
# สร้างกุญแจส่วนตัวสำหรับ CA
openssl genrsa -out ca_private_key.pem 2048
```

2. สร้างใบรับรองที่ลงนามด้วยตนเองสำหรับ CA:
```bash
# สร้างใบรับรองที่ลงนามด้วยตนเองสำหรับ CA (Self-signed Certificate)
openssl req -x509 -new -nodes -key ca_private_key.pem -sha256 -days 365 -out ca_cert.pem
```

ในขั้นตอนนี้ คุณจะถูกถามข้อมูลต่างๆ เช่น:
- Country Name: TH
- State or Province Name: Bangkok
- Locality Name: Bangkok
- Organization Name: MyCA
- Organizational Unit Name: Certificate Authority
- Common Name: My Certificate Authority
- Email Address: ca@example.com

คำอธิบาย:
- `-x509` ระบุว่าเป็นการสร้างใบรับรอง X.509
- `-new` ระบุว่าเป็นการสร้างคำขอใบรับรองใหม่
- `-nodes` ไม่ต้องการเข้ารหัสกุญแจส่วนตัว
- `-key` ระบุกุญแจส่วนตัวที่จะใช้
- `-sha256` ใช้อัลกอริทึม SHA-256 ในการลงนาม
- `-days 365` ระบุอายุของใบรับรอง (1 ปี)
- `-out ca_cert.pem` ระบุไฟล์ที่จะเก็บใบรับรอง

3. ตรวจสอบข้อมูลในใบรับรอง CA:
```bash
# ตรวจสอบข้อมูลในใบรับรอง CA
openssl x509 -in ca_cert.pem -text -noout
```

ผลลัพธ์จะแสดงข้อมูลทั้งหมดในใบรับรอง เช่น:
- ผู้ออกใบรับรอง (Issuer)
- ระยะเวลาที่มีผล (Validity)
- เจ้าของใบรับรอง (Subject)
- กุญแจสาธารณะ (Public Key)
- ลายมือชื่อดิจิทัล (Signature)

### ขั้นตอนที่ 3.2: สร้างคู่กุญแจและคำขอใบรับรองสำหรับเว็บไซต์

1. สร้างกุญแจส่วนตัวสำหรับเว็บไซต์:
```bash
# สร้างกุญแจส่วนตัวสำหรับเว็บไซต์
openssl genrsa -out website_private_key.pem 2048
```

2. สร้างคำขอใบรับรอง (CSR):
```bash
# สร้างคำขอใบรับรอง (CSR)
openssl req -new -key website_private_key.pem -out website_request.csr
```

ใส่ข้อมูลต่างๆ ตามที่ต้องการ โดยที่ Common Name ต้องตรงกับชื่อโดเมนที่จะใช้ เช่น "example.local"

3. ตรวจสอบข้อมูลในคำขอใบรับรอง:
```bash
# ตรวจสอบข้อมูลในคำขอใบรับรอง
openssl req -in website_request.csr -text -noout
```

### ขั้นตอนที่ 3.3: ออกใบรับรองให้เว็บไซต์

```bash
# ออกใบรับรองให้เว็บไซต์โดยใช้ CA
openssl x509 -req -in website_request.csr -CA ca_cert.pem -CAkey ca_private_key.pem -CAcreateserial -out website_cert.pem -days 365 -sha256
```

คำอธิบาย:
- `-req` ระบุว่าอินพุตเป็นคำขอใบรับรอง
- `-CA ca_cert.pem` ระบุใบรับรองของ CA
- `-CAkey ca_private_key.pem` ระบุกุญแจส่วนตัวของ CA
- `-CAcreateserial` สร้างไฟล์ serial number สำหรับ CA
- `-out website_cert.pem` ระบุไฟล์ที่จะเก็บใบรับรองที่ออกให้

### ขั้นตอนที่ 3.4: ตรวจสอบข้อมูลในใบรับรองที่ออกให้

```bash
# ตรวจสอบข้อมูลในใบรับรองที่ออกให้
openssl x509 -in website_cert.pem -text -noout
```

สังเกตว่าข้อมูล Issuer จะเป็นของ CA และข้อมูล Subject จะเป็นของเว็บไซต์

### ขั้นตอนที่ 3.5: ตรวจสอบว่าใบรับรองเว็บไซต์ได้รับการลงนามจาก CA จริง

```bash
# ตรวจสอบใบรับรองเว็บไซต์ด้วยใบรับรอง CA
openssl verify -CAfile ca_cert.pem website_cert.pem
```

ผลลัพธ์ที่ควรได้:
```
website_cert.pem: OK
```

## ส่วนที่ 4: การจำลองการใช้งานใบรับรองกับเว็บเซิร์ฟเวอร์

### ขั้นตอนที่ 4.1: เตรียมไฟล์ HTML ทดสอบ

```bash
# สร้างไฟล์ HTML ทดสอบ
cat > index.html << EOF
<!DOCTYPE html>
<html>
<head>
    <title>ทดสอบ PKI</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>การทดสอบ PKI และ HTTPS</h1>
    <p>เว็บเพจนี้ถูกเข้าถึงผ่านการเชื่อมต่อ HTTPS ที่ปลอดภัย</p>
    <p>ใบรับรองถูกออกโดย CA ที่เราสร้างขึ้นเอง</p>
</body>
</html>
EOF
```

### ขั้นตอนที่ 4.2: สร้างไฟล์ Python สำหรับเว็บเซิร์ฟเวอร์

```bash
# สร้างไฟล์ Python สำหรับเว็บเซิร์ฟเวอร์
cat > https_server.py << EOF
import http.server
import ssl

port = 4443
server_address = ('localhost', port)
httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)

# ตั้งค่า SSL context
ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ssl_context.load_cert_chain('website_cert.pem', 'website_private_key.pem')

httpd.socket = ssl_context.wrap_socket(httpd.socket, server_side=True)

print(f'เริ่มต้นเซิร์ฟเวอร์ที่ https://localhost:{port}')
httpd.serve_forever()
EOF
```

### ขั้นตอนที่ 4.3: แก้ไขไฟล์ hosts (ถ้าต้องการใช้ชื่อโดเมนอื่น)

หากต้องการใช้ชื่อโดเมนเช่น example.local แทนการใช้ localhost:

```bash
# สำหรับ Linux/macOS (ต้องใช้สิทธิ์ root)
sudo sh -c 'echo "127.0.0.1 example.local" >> /etc/hosts'

# สำหรับ Windows (ต้องรัน Command Prompt ด้วยสิทธิ์ Administrator)
# echo 127.0.0.1 example.local >> %WINDIR%\System32\drivers\etc\hosts
```

### ขั้นตอนที่ 4.4: รันเว็บเซิร์ฟเวอร์

```bash
# รันเว็บเซิร์ฟเวอร์
python3 https_server.py
```

### ขั้นตอนที่ 4.5: เข้าถึงเว็บไซต์ด้วยเบราว์เซอร์

1. เปิดเว็บเบราว์เซอร์และไปที่ `https://localhost:4443` หรือ `https://example.local:4443` (ถ้าตั้งค่า hosts ไว้)
2. เบราว์เซอร์จะแสดงคำเตือนเกี่ยวกับใบรับรองที่ไม่น่าเชื่อถือ (เพราะ CA ของเราไม่ได้รับการยอมรับจากเบราว์เซอร์)
3. ยอมรับความเสี่ยงและดำเนินการต่อ
4. คุณจะเห็นเว็บเพจทดสอบที่ถูกเข้าถึงผ่าน HTTPS

### ขั้นตอนที่ 4.6: ติดตั้งใบรับรอง CA ในเบราว์เซอร์ (ไม่จำเป็น แต่แนะนำให้ทำ)

การติดตั้งใบรับรอง CA ในเบราว์เซอร์จะทำให้เบราว์เซอร์ยอมรับใบรับรองที่ออกโดย CA ของเราโดยไม่แสดงคำเตือน

วิธีการขึ้นอยู่กับเบราว์เซอร์และระบบปฏิบัติการ แต่โดยทั่วไปคือ:

1. Firefox:
   - ไปที่ Settings > Privacy & Security > Certificates > View Certificates
   - เลือกแท็บ Authorities
   - คลิก Import และเลือกไฟล์ ca_cert.pem
   - เลือก "Trust this CA to identify websites"

2. Chrome/Edge (บน Windows):
   - ไปที่ Settings > Privacy and security > Security > Manage certificates
   - เลือกแท็บ Trusted Root Certification Authorities
   - คลิก Import และเลือกไฟล์ ca_cert.pem

3. Chrome/Safari (บน macOS):
   - ดับเบิลคลิกที่ไฟล์ ca_cert.pem
   - Keychain Access จะเปิดขึ้น
   - เพิ่มใบรับรองเข้าไปใน System keychain
   - เปิดใบรับรองและตั้งค่า "Trust" เป็น "Always Trust"

## สรุปแนวคิดสำคัญ

### 1. กุญแจคู่ในระบบ PKI
- กุญแจส่วนตัว (Private Key): ต้องเก็บเป็นความลับ ใช้สำหรับถอดรหัสข้อมูลและลงนามดิจิทัล
- กุญแจสาธารณะ (Public Key): เผยแพร่ให้ผู้อื่นได้ ใช้สำหรับเข้ารหัสข้อมูลและตรวจสอบลายมือชื่อ

### 2. ลายมือชื่อดิจิทัล
- ใช้กุญแจส่วนตัวในการลงนาม
- ใช้กุญแจสาธารณะในการตรวจสอบลายมือชื่อ
- รับประกันความถูกต้องของข้อมูล (Integrity) และความเป็นเจ้าของ (Authentication)
- ช่วยให้ไม่สามารถปฏิเสธความรับผิดชอบได้ (Non-repudiation)

### 3. ใบรับรองดิจิทัล
- เป็นเอกสารดิจิทัลที่รับรองความเป็นเจ้าของของกุญแจสาธารณะ
- ประกอบด้วยข้อมูลเจ้าของ กุญแจสาธารณะ และลายมือชื่อของผู้ออกใบรับรอง (CA)
- ช่วยแก้ปัญหาการยืนยันตัวตนในระบบเปิด (เช่น อินเทอร์เน็ต)

### 4. โครงสร้างพื้นฐานกุญแจสาธารณะ (PKI)
- เป็นระบบที่รวมนโยบาย ฮาร์ดแวร์ ซอฟต์แวร์ และขั้นตอนต่างๆ เพื่อสร้าง จัดการ แจกจ่าย ใช้ เก็บ และเพิกถอนใบรับรองดิจิทัล
- หัวใจสำคัญคือความไว้วางใจ (Trust) ระหว่างผู้ใช้และ CA
- CA ทำหน้าที่เป็นบุคคลที่สามที่เชื่อถือได้ รับรองความเป็นเจ้าของของกุญแจสาธารณะ

### 5. การใช้งาน PKI ในโลกจริง
- การเชื่อมต่อเว็บไซต์แบบ HTTPS
- ระบบอีเมลที่มีการเข้ารหัส (S/MIME)
- ลายมือชื่ออิเล็กทรอนิกส์สำหรับเอกสาร
- บัตรประจำตัวอิเล็กทรอนิกส์ (Smart Card)
- VPN และระบบเครือข่ายที่ปลอดภัย

## คำถามทบทวนความเข้าใจและคำตอบ

### 1. อธิบายความแตกต่างระหว่างการเข้ารหัสแบบสมมาตรและอสมมาตร
**คำตอบ**: 
- **การเข้ารหัสแบบสมมาตร** ใช้กุญแจเดียวกันสำหรับทั้งการเข้ารหัสและถอดรหัส มีความเร็วในการประมวลผลสูง แต่มีปัญหาในการแลกเปลี่ยนกุญแจอย่างปลอดภัย ตัวอย่างเช่น AES, DES
- **การเข้ารหัสแบบอสมมาตร** ใช้คู่กุญแจที่แตกต่างกันสำหรับการเข้ารหัส (กุญแจสาธารณะ) และถอดรหัส (กุญแจส่วนตัว) ช้ากว่าแบบสมมาตรแต่แก้ปัญหาการแลกเปลี่ยนกุญแจและทำให้มีระบบลายมือชื่อดิจิทัลได้ ตัวอย่างเช่น RSA, ECC

### 2. อธิบายวิธีการที่ PKI ช่วยแก้ปัญหาการยืนยันตัวตนในอินเทอร์เน็ต
**คำตอบ**: 
PKI แก้ปัญหาการยืนยันตัวตนโดยใช้หน่วยรับรอง (CA) ที่เชื่อถือได้มาลงนามรับรองความเป็นเจ้าของของกุญแจสาธารณะ โดยออกใบรับรองดิจิทัลที่มีข้อมูลเจ้าของและกุญแจสาธารณะพร้อมลายมือชื่อของ CA เมื่อผู้ใช้เชื่อถือ CA แล้ว ก็จะสามารถเชื่อถือใบรับรองที่ออกโดย CA นั้นได้ ทำให้สามารถยืนยันตัวตนของผู้อื่นได้แม้ไม่เคยพบกันมาก่อน

### 3. เปรียบเทียบหน้าที่ของลายมือชื่อดิจิทัลและการเข้ารหัสข้อมูล
**คำตอบ**: 
- **ลายมือชื่อดิจิทัล** มีวัตถุประสงค์เพื่อรับรองความถูกต้องของข้อมูล (Integrity) และความเป็นเจ้าของ (Authentication) รวมถึงการไม่สามารถปฏิเสธความรับผิดชอบได้ (Non-repudiation) โดยใช้กุญแจส่วนตัวในการลงนามและกุญแจสาธารณะในการตรวจสอบ
- **การเข้ารหัสข้อมูล** มีวัตถุประสงค์เพื่อรักษาความลับของข้อมูล (Confidentiality) โดยใช้กุญแจสาธารณะในการเข้ารหัสและกุญแจส่วนตัวในการถอดรหัส

### 4. อธิบายขั้นตอนการทำงานของ HTTPS โดยเน้นบทบาทของ PKI
**คำตอบ**: 
HTTPS ใช้ PKI ในขั้นตอนต่อไปนี้:
1. เว็บเซิร์ฟเวอร์มีใบรับรองที่ออกโดย CA ที่เชื่อถือได้
2. เมื่อผู้ใช้เข้าถึงเว็บไซต์ เซิร์ฟเวอร์ส่งใบรับรองที่มีกุญแจสาธารณะของเซิร์ฟเวอร์
3. เบราว์เซอร์ตรวจสอบใบรับรองโดยใช้กุญแจสาธารณะของ CA ที่ติดตั้งไว้แล้ว
4. เบราว์เซอร์สร้างกุญแจลับสำหรับเซสชัน (Session Key) และเข้ารหัสด้วยกุญแจสาธารณะของเซิร์ฟเวอร์
5. เซิร์ฟเวอร์ถอดรหัสด้วยกุญแจส่วนตัวเพื่อรับกุญแจเซสชัน
6. จากนั้นการสื่อสารทั้งหมดจะใช้การเข้ารหัสแบบสมมาตรด้วยกุญแจเซสชัน

### 5. หากเกิดกรณีที่กุญแจส่วนตัวของ CA รั่วไหล จะส่งผลกระทบอย่างไรและมีวิธีแก้ไขอย่างไร
**คำตอบ**: 
ผลกระทบ:
- ผู้ไม่ประสงค์ดีสามารถออกใบรับรองปลอมที่ดูเหมือนออกโดย CA นั้น
- สามารถปลอมแปลงเว็บไซต์หรือบริการโดยที่ผู้ใช้จะไม่ได้รับการเตือน
- ทำให้ระบบความปลอดภัยทั้งหมดที่อาศัย CA นี้ถูกบุกรุกได้

วิธีแก้ไข:
- เพิกถอนใบรับรองของ CA นั้นทันที (Revocation)
- ออก Certificate Revocation List (CRL) ที่ระบุใบรับรองทั้งหมดที่ออกโดย CA นี้
- ใช้ Online Certificate Status Protocol (OCSP) เพื่อให้ระบบสามารถตรวจสอบสถานะของใบรับรองแบบเรียลไทม์
- ออกใบรับรองใหม่โดย CA สำรองหรือ CA ระดับที่สูงกว่า
- แจ้งเตือนผู้ใช้และอัพเดทซอฟต์แวร์เพื่อไม่ให้เชื่อถือ CA ที่มีปัญหา

## การประยุกต์ใช้ความรู้ต่อยอด

1. **การทำ Multi-factor Authentication**:
   - ใช้ใบรับรองดิจิทัลร่วมกับวิธีการยืนยันตัวตนอื่นๆ เช่น รหัสผ่าน หรือ OTP

2. **การพัฒนาระบบ E-Signature**:
   - สร้างระบบลายมือชื่ออิเล็กทรอนิกส์สำหรับเอกสารสำคัญ

3. **การทำ Code Signing**:
   - ใช้ลายมือชื่อดิจิทัลเพื่อรับรองความถูกต้องของโค้ดหรือแอปพลิเคชัน

4. **การพัฒนา Secure Email System**:
   - ใช้ S/MIME หรือ PGP เพื่อเข้ารหัสและลงนามในอีเมล

5. **การพัฒนา Private PKI**:
   - สร้างโครงสร้าง PKI ภายในองค์กรเพื่อรักษาความปลอดภัยของระบบภายใน
