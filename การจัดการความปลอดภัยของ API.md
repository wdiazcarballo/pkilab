# การรักษาความปลอดภัยในระบบ Backend สำหรับแอปพลิเคชัน Flip-Card

บทความนี้จะทบทวนความเข้าใจเรื่องการรักษาความปลอดภัยในส่วน Backend ของแอปพลิเคชัน Flip-Card ที่เราได้พัฒนาขึ้น โดยใช้เมทาฟอร์ของร้านอาหาร ซึ่งจะช่วยให้เราเข้าใจได้ง่ายขึ้น

## ภาพรวมของระบบ

ลองนึกภาพว่าแอปพลิเคชันของเราเป็นเหมือนร้านอาหาร:

- **API** คือ "พนักงานเสิร์ฟ" ที่รับคำสั่งจากลูกค้า (ผู้ใช้) และส่งต่อไปยังครัว
- **Backend** คือ "ครัว" ที่เตรียมอาหาร (ข้อมูล) ตามที่ลูกค้าสั่ง
- **ฐานข้อมูล** คือ "คลังวัตถุดิบ" ที่เก็บวัตถุดิบทั้งหมดของร้าน

มาดูกันว่าเรามีระบบรักษาความปลอดภัยอะไรบ้างในร้านอาหารแห่งนี้

## 1. การยืนยันตัวตนด้วย JWT (JSON Web Token)

**เมทาฟอร์**: "บัตรสมาชิกร้านอาหาร" ที่ต้องแสดงเมื่อสั่งอาหาร

เมื่อนักศึกษาล็อกอินเข้าระบบ (เหมือนสมัครสมาชิกร้านอาหาร) ระบบจะออก "บัตรสมาชิก" (JWT token) ให้ บัตรนี้มีข้อมูลรหัสสมาชิกและวันหมดอายุ ทุกครั้งที่สั่งอาหาร พนักงานเสิร์ฟ (API) จะขอดูบัตรสมาชิกก่อน ถ้าบัตรปลอมหรือหมดอายุ พนักงานจะปฏิเสธการรับออเดอร์

```javascript
// พนักงานเสิร์ฟตรวจสอบบัตรสมาชิกก่อนรับออเดอร์
exports.protect = async (req, res, next) => {
  let token;
  
  // ตรวจดูว่ามีบัตรสมาชิกหรือไม่
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }
  
  // ถ้าไม่มีบัตรสมาชิก
  if (!token) {
    return res.status(401).json({ 
      success: false, 
      message: 'กรุณาแสดงบัตรสมาชิกก่อนสั่งอาหาร' 
    });
  }
  
  // ตรวจสอบว่าบัตรสมาชิกเป็นของจริงและยังไม่หมดอายุ
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.id);
    next();
  } catch (error) {
    return res.status(401).json({ 
      success: false, 
      message: 'บัตรสมาชิกไม่ถูกต้องหรือหมดอายุ' 
    });
  }
};
```

## 2. การเข้ารหัสรหัสผ่านด้วย bcryptjs

**เมทาฟอร์**: "เมนูลับที่มีรหัสพิเศษ"

ในร้านอาหารของเรา มีเมนูพิเศษที่ลูกค้าต้องรู้รหัสเฉพาะ แต่พนักงานเสิร์ฟและเชฟไม่ได้จดจำรหัสเมนูพิเศษโดยตรง แต่จะจำแค่ "รอยเลอะ" ของรหัสเท่านั้น เมื่อลูกค้าบอกรหัส พนักงานจะดูว่ารอยเลอะที่เกิดจากรหัสนั้นตรงกับที่จำไว้หรือไม่

นี่คือวิธีที่ระบบเก็บรหัสผ่านของนักศึกษา - ไม่เก็บรหัสผ่านจริง แต่เก็บเฉพาะ "รอยเลอะ" (hash) ที่เกิดจากรหัสผ่านนั้น

```javascript
// เมื่อลูกค้าตั้งรหัสเมนูพิเศษ เราจะเก็บแค่รอยเลอะไว้
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) {
    next();
  }
  
  const salt = await bcrypt.genSalt(10); // เหมือนการเตรียมเครื่องปรุงรอยเลอะ
  this.password = await bcrypt.hash(this.password, salt); // สร้างรอยเลอะจากรหัส
});

// เวลาตรวจสอบรหัส เราดูว่ารหัสที่ลูกค้าบอกจะสร้างรอยเลอะเหมือนที่เก็บไว้หรือไม่
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};
```

## 3. การจัดการสิทธิ์และการอนุญาต

**เมทาฟอร์**: "การแบ่งโซนในร้านอาหาร"

ในร้านอาหารหรู มีการแบ่งโซนพิเศษ เช่น โซน VIP หรือห้องจัดเลี้ยงส่วนตัว ลูกค้าที่มีบัตรสมาชิกระดับปกติจะเข้าได้เฉพาะพื้นที่ทั่วไป แต่บัตรระดับ VIP จะเข้าได้ทุกโซน

ในระบบของเรา เรามีการกำหนดบทบาท (role) ให้ผู้ใช้ เช่น 'user' หรือ 'admin' และตรวจสอบว่าผู้ใช้มีสิทธิ์เข้าถึงทรัพยากรนั้นหรือไม่

```javascript
// พนักงานเสิร์ฟตรวจสอบว่าลูกค้ามีบัตรระดับที่เข้าโซนนี้ได้หรือไม่
exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ 
        success: false, 
        message: 'ขออภัย คุณไม่มีสิทธิ์เข้าโซนพิเศษนี้' 
      });
    }
    next();
  };
};

// ตรวจสอบว่าเป็นเจ้าของโต๊ะจริงหรือไม่
if (category.user.toString() !== req.user._id.toString()) {
  return res.status(403).json({ success: false, message: 'นี่ไม่ใช่โต๊ะของคุณ ไม่สามารถแก้ไขออเดอร์ได้' });
}
```

## 4. การป้องกันการโจมตี XSS และ CSRF

**เมทาฟอร์**: "พนักงานตรวจสอบอาหาร"

ในครัวของเรามีพนักงานตรวจสอบอาหารก่อนส่งออกจากครัว เพื่อให้แน่ใจว่าไม่มีสิ่งแปลกปลอมในอาหาร Helmet ทำหน้าที่เหมือนพนักงานเหล่านี้ โดยตรวจสอบข้อมูลที่ส่งออกจากเซิร์ฟเวอร์และตั้งค่า HTTP headers เพื่อป้องกันการโจมตีต่างๆ

```javascript
// จ้างพนักงานตรวจสอบอาหารประจำครัว
app.use(helmet());
```

## 5. การจำกัดอัตราการเรียกใช้ API (Rate Limiting)

**เมทาฟอร์**: "กฎการสั่งอาหาร"

ร้านอาหารของเรามีกฎว่า 1 โต๊ะสามารถเรียกพนักงานเสิร์ฟได้ไม่เกิน 100 ครั้งในเวลา 15 นาที เพื่อไม่ให้พนักงานต้องวิ่งกันจนเหนื่อย และให้บริการได้อย่างมีประสิทธิภาพ

```javascript
// กฎร้าน: 1 โต๊ะเรียกพนักงานได้ไม่เกิน 100 ครั้งใน 15 นาที
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 นาที
  max: 100, // จำกัดการเรียก 100 ครั้งต่อ IP
  message: {
    success: false,
    message: 'คุณเรียกพนักงานเสิร์ฟบ่อยเกินไป กรุณารอสักครู่',
  },
});

app.use('/api', apiLimiter);
```

## 6. การตรวจสอบความถูกต้องของข้อมูล (Validation)

**เมทาฟอร์**: "พนักงานเสิร์ฟตรวจสอบออเดอร์"

ก่อนที่พนักงานเสิร์ฟจะส่งออเดอร์เข้าครัว เขาจะตรวจสอบว่าออเดอร์สมบูรณ์หรือไม่ เช่น มีชื่อเมนู จำนวน ความต้องการพิเศษ ที่ระบุชัดเจน ถ้าออเดอร์ไม่ชัดเจน พนักงานจะขอให้ลูกค้าสั่งใหม่

```javascript
// พนักงานเสิร์ฟตรวจสอบว่าออเดอร์สมบูรณ์หรือไม่
[
  check('username', 'กรุณาระบุชื่อผู้ใช้').not().isEmpty(),
  check('email', 'กรุณาระบุอีเมลที่ถูกต้อง').isEmail(),
  check('password', 'กรุณาระบุรหัสผ่านที่มีความยาวอย่างน้อย 8 ตัวอักษร').isLength({ min: 8 }),
]
```

## 7. การจัดการข้อผิดพลาด

**เมทาฟอร์**: "ผู้จัดการร้าน"

ในร้านอาหาร เมื่อมีปัญหาเกิดขึ้น เช่น วัตถุดิบหมด ออเดอร์ผิดพลาด หรือลูกค้าไม่พอใจ ผู้จัดการร้านจะเข้ามาจัดการ ในระบบของเรา เรามี errorHandler เป็นเหมือนผู้จัดการที่รู้จักปัญหาทุกประเภทและรู้วิธีจัดการอย่างเหมาะสม

```javascript
// ผู้จัดการร้านจัดการปัญหาต่างๆ
const errorHandler = (err, req, res, next) => {
  // จัดการกับปัญหาแต่ละประเภท
  if (err.name === 'CastError') {
    // เหมือนผู้จัดการรู้ว่า "ไม่มีเมนูนี้" ต้องแจ้งลูกค้า
    const message = 'ไม่พบข้อมูลที่ต้องการ';
    return res.status(404).json({ success: false, message });
  }
  
  if (err.code === 11000) {
    // เหมือนผู้จัดการรู้ว่า "มีออเดอร์นี้แล้ว" ต้องแจ้งลูกค้า
    const message = 'มีข้อมูลนี้อยู่ในระบบแล้ว';
    return res.status(400).json({ success: false, message });
  }
  
  // จัดการกับปัญหาทั่วไป
  res.status(error.statusCode || 500).json({
    success: false,
    message: error.message || 'มีปัญหาในครัว กรุณารอสักครู่',
  });
};
```

## สรุป

นักศึกษาครับ การรักษาความปลอดภัยใน Backend ของเราเปรียบเสมือนระบบรักษาความปลอดภัยของร้านอาหารที่มีหลายส่วน:

1. **JWT**: เป็นเหมือนบัตรสมาชิกร้านอาหารที่ต้องแสดงเมื่อสั่งอาหาร
2. **bcryptjs**: เหมือนการจดจำรอยเลอะของรหัสเมนูพิเศษแทนที่จะจำรหัสจริง
3. **การจัดการสิทธิ์**: เหมือนการแบ่งโซนในร้านอาหารที่ลูกค้าต้องมีสิทธิ์เข้าถึง
4. **Helmet**: เหมือนพนักงานตรวจสอบอาหารก่อนส่งออกจากครัว
5. **Rate Limiting**: เหมือนกฎไม่ให้เรียกพนักงานเสิร์ฟบ่อยเกินไป
6. **Validation**: เหมือนพนักงานเสิร์ฟตรวจสอบว่าออเดอร์สมบูรณ์ก่อนส่งเข้าครัว
7. **Error Handling**: เหมือนผู้จัดการร้านที่จัดการกับปัญหาต่างๆ

การมีระบบรักษาความปลอดภัยหลายชั้นนี้ช่วยให้แอปพลิเคชัน ที่ส่งรับข้อมูลผ่านอินเตอร์เน็ตมีความน่าเชื่อถือขึ้น